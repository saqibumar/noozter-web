import { Component, OnInit } from '@angular/core';
import { PfDataService, IContextModel } from '../../data.service';
import { ContextModel } from '../../models/context.model';
import { UDFModel } from '../../models/udf.model';
import { Observable } from 'rxjs/Observable';
import { ObservableModel } from '../../models/obs.model';

@Component({
  selector: 'pf-devpanel',
  templateUrl: './devpanel.component.html',
  styleUrls: ['./devpanel.component.css']
})
export class PfDevPanelComponent implements OnInit {

  data: Observable<UDFModel>;
  observables: Observable<UDFModel>[] = [];

  requestTypes: any[] = [];
  sidemapNodes: any[];

  productionDate: string;

  selectedNode: object;
  selectedType: object;

  query: string;

  context: ContextModel<IContextModel>;

  private defaults = {
    path: void 0,
    lcc: 'com',
    lcd: 'de',
    psg: void 0,
    psh: void 0,
    from: 0,
    count: 10
  };

  constructor(private pfinderService: PfDataService) {
    this.context = new ContextModel(this.defaults);
  }


  ngOnInit() {

    Object.keys(PfDataService.requestTypes).forEach(key => {
      this.requestTypes.push({name: key, value: PfDataService.requestTypes[key]});
    });

    this.pfinderService.login(this.context);

    this._getSideMapList();
    this._getProductionDate();
  }

  public setNode($e) {
    if (this.selectedType)
      this.setRequestType(this.selectedType);
  }

  public setQuery(query: string) {
    this.query = query;
    if (this.selectedType)
      this.setRequestType(this.selectedType);
  }

  public onSettingsChange($event) {
    this.pfinderService.login($event);
  }

  public setRequestType(obj: any): void {

    // We can just forget about the old observables as they where added to template as
    // async observable and therefor they are unsubscribed automatically by angular.
    // Note: If there are no more subscriptions to an observable the model will
    // be destroyed automatically too. By resubscription to a reference of udf observable,
    // data is refeched and a new model is created.
    this.observables = [];

    let observable: Observable<UDFModel>;

    switch (obj.name) {
      case 'LOGIN':
        observable = this.pfinderService.login();
        break;
      case 'MASK':
        const maskParams = {
          path: this.selectedNode['path'],
          from: 0,
          count: 2
        };
        this.context.path = this.selectedNode['path'];
        /*
        maskParams['psg'] = 'c0000002300000e4d00010023sg_0000000000000edc0002003e|301561741';
        maskParams['path'] = 'c0000002300000e4d00010023';
        */
        observable = this.pfinderService.getMask(this.context);
        this.observables.push(observable);

        observable = this.pfinderService.getList(observable);
        this.observables.push(observable);

        /*
        observable.subscribe(res => {
          observable = this.pfinderService.getList(res.context);
          this.observables.push(observable);
        })
        */

        break;
      case 'LIST':
        observable = this.pfinderService.getList({path: this.selectedNode['path'], from: 0, count: 1}, this.query);
        this.observables.push(observable);
        break;
      case 'DETAIL':
        observable = this.pfinderService.getDetail({path: this.selectedNode['path']}, this.query);
        this.observables.push(observable);
        break;
    }

  }

  private _getSideMapList(): void {
    const subscription = this.pfinderService.getSitemap()
      .subscribe(udf => {
      subscription.unsubscribe();
      this.sidemapNodes = udf.query('compound[name=sitemap-data]>record');
    });
  }

  private _getProductionDate(): void {
    const subscription = this.pfinderService.getSessionData('production_date')
      .subscribe(timeStemp => {
        this.productionDate = timeStemp;
        subscription.unsubscribe();
      });
  }

}
