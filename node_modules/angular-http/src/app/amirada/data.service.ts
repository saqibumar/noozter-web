import { Injectable, NgZone } from '@angular/core';
import { Http, Response, Headers, URLSearchParams, RequestOptions } from '@angular/http';

import { Observable } from 'rxjs/Observable';
import { Subscriber } from 'rxjs/Subscriber';
import { Subscription } from 'rxjs/Subscription';

import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/map';

import {UDFData, UDFModel} from './models/udf.model';
import { MaskModel } from './models/mask.model';
import { ListModel } from './models/list.model';
import { ObservableModel } from './models/obs.model';
import { ContextModel } from './models/context.model';

import { XArray } from './models/xarray';


interface ISessionData {
  companies: any[];
  countries: any[];
  sitemap: any[];
  langdata: object;
  langguidata: object;
  currencysettings: string;
  lcc: string;
  lcd: string;
  lcg: string;
  production_date: string;
  /**
   * psf is a comma separated string of which each item is divided by pipe
   * of witch first is key rest are values
   */
  psf: string;
  user: string;
  login: object; /** (loggedin:true, user:'username'} */
}

export interface IOptionListItem {
  desc: string;
  value: any;
  type: string;
  active?: boolean;
}

export interface IContextModel {
  user?: string;
  login?: string;
  path?: string;
  lcc?: string;
  lcd?: string;
  fnc?: number;
  from?: number;
  count?: number;
}

export interface ILoginParams {
  user?: string;
  login?: string;
  lcc?: string;
  lcd?: string;
  fnc?: number;
  smp?: number;
}
class LoginParams extends ContextModel<LoginParams> implements ILoginParams {
  public params: ILoginParams  = {
    fnc: PfDataService.requestTypes.LOGIN,
    user: void 0, login: void 0, lcc: void 0, lcd: void 0, smp: 7
  };
}

export interface IMaskParams {
  path?: string;
  psg?: string | object;
  psh?: string | object;
  fnc?: number;
}

class MaskParams extends ContextModel<LoginParams> implements IMaskParams {
  public params: IMaskParams  = {
    fnc: PfDataService.requestTypes.MASK,
    path: void 0, psg: void 0, psh: void 0
  };
}

export interface IListParams {
  path?: string;
  psg?: string | object;
  psh?: string | object;
  from?: number;
  count?: number;
  sort_by?: string;
  sort_order?: string;
  fnc?: number;
}

class ListParams extends ContextModel<LoginParams> implements IListParams {
  public params: IListParams  = {
    fnc: PfDataService.requestTypes.LIST,
    path: void 0, psg: void 0, psh: void 0, from: void 0, count: void 0,
    sort_by: void 0, sort_order: 'asc'
  };
}



export interface IDetailParams {
  path?: string;
  fnc?: number;
}

class DetailParams extends ContextModel<LoginParams> implements IDetailParams {
  public params: IMaskParams  = {
    fnc: PfDataService.requestTypes.DETAIL,
    path: void 0
  };
}

@Injectable()
export class PfDataService {

  static singleton: PfDataService;
  static requestTypes = {
    LOGIN:    0,
    /**
     * @param {string} path - The mask path or cat
     * @param {string} [psg] - i.e. "c0000002a0003a61e00010023sg_000000120002a67b0001003e|389203453|372162334[,<next-item>]"
     * The psg/psh string is a comma separated string. Each item is separated my pipe of which first element is the property
     * and the following elements are the selected values.
     * So, the string above could be: [{c0000002a0003a61e00010023sg_000000120002a67b0001003e:["389203453","372162334"]}],
     * or: {prop:c0000002a0003a61e00010023sg_000000120002a67b0001003e,values:["389203453","372162334"]}
     * @param {string} [psh]
     * @return {object} - MaskModel (derived from UDFModel)
     */
    MASK:   5,

    /** Same params as for mask */
    LIST: 6,

    /**
     * @param {string} path - Category/Mask/Series ID
     * @return {object} - ListModel (derived from UDFModel)
     */
    DETAIL: 31,

    /**
     * @param {sting} test - Search input string
     * @param {number} from - Maximum suggesstions returned
     */
    // SEARCH: 19,

    /**
     * Returnst a list of searchable strings containing @param text.
     * Params for SEARCH_SUGGEST are:
     * @param {sting} test - Search input string
     * @param {number} max - Maximum suggesstions returned
     */
    // SEARCH_SUGGESTIONS: 29
  };



  /**
   * Endpoint URL of pfinder service.
   * @type {string}
   * @private
   */

  static baseUrl = 'http://wilo.amirada.net/stage_0/server/scripts/base/pfinder.php';
  // static baseUrl = '/pfproxy/';

  /**
   * Default URL search params to build a request URL. Used in _getURLParams
   * in which default params can be overridden by passing @mixIn params as argument.
   * @type {{client:string; device:string; prog:string; ucid:string; json:string; smp:string; lcc:string; lcd:string; act:string}}
   * @private
   */
  private _baseArgs = {
    client: 'wilo',
    device: 'desk',
    prog: 'pfinder',
    ucid: '10d25187-ccbd-2f31-a4ed-dfd4f7d37c14',
    json: '1',
    // smp: '7', /* What was that again? */
    act: 'getData' /* Service interface */
  };

  private _results: Object = {};
  private _subscribers: Object = {};
  private _params: Object = {};


  /**
   * The session object is payload of the login request.
   * This object is needed for lookups, translations, etc.
   * and has to be requested first of all by login method.
   * Note: The implementation checks for any request if session data exists,
   * if this is not the case session data is fetched automaticaly (anonymous login).
   * It holds:
   * companies {array<object>}
   * countries {array<object>}
   * currencysettings {string} - ie. "DEC=,|THP=.|DDL=|CUR=|LNG=DE|LNI=1"
   * langguidata {object} - translations
   * lcc {string} - current country code
   * lcd {string} - current language code of date for this country.
   * lcg {string} - current gui language code (langguidata)
   * login {object} - login status
   * sitemap {array} - Tree data as a list needed for lookup if id is of type mask, series (cat) or product (pid) for example.
   * ...
   */
  private _sessionData: ISessionData;

  static queryStringToObj(str: string = '', d1: string = '&', a: string = '=', d2?: string, decode?: boolean, keyToUpper?: boolean ): object {
    if (str === null) str = ''; /* transpilation let's null get though without setting default */
    const obj = {};
    const expStr = `([^${d1}${a}]+)(${a}([^${d1}${a}]*))?`;
    const exp = RegExp(expStr, 'g');
    str.replace(exp, (
      ($0, $1, $2, $3) => {
        if (decode && $3) $3 = decodeURIComponent($3);
        if (d2 && $3) $3 = $3.split(d2);
        if ($3) { obj[ keyToUpper ? $1.toUpperCase() : $1 ] = $3; }
      }).bind(this));
    return obj;
  };

  static objToQueryString(obj: Object, d1: string = ',', a: string = '=', d2 = '|', encode?: boolean): string {
    const arr = [];
    Object.keys(obj).forEach(key => {
      let value = (obj[key] instanceof Array ? obj[key].join(d2) : obj[key].toString() );
      if (encode) value = encodeURIComponent(value);
      arr.push(key + a + value);
    });
    return arr.join(d1);
  }

  /**
   * The ps (psg/psh/psf) format is a comma separated string. Each item is separated by pipe of which
   * first element is the property and the following elements are the selected values.
   * i.e. p1|a|b,p2|c converts to {p1:['a','b'],p2:['c']}
   * @param str
   * @return {{}}
   * @private
   */
  static psToObj(str: string): Object {
    const res = {};
    str.split(',').forEach(item => {
      const item_arr = item.split('|');
      res[item_arr[0]] = item_arr.slice(1);
    })
    return res;
  }

  /**
   * Encoding object to ps formated string.
   * @param obj
   * @return {string}
   * @private
   */
  static objToPs(obj: Object): string {
    return PfDataService.objToQueryString(obj, ',', '|', '|');
  }

  /**
   * In the constructor we save a static singleton instance in PfDataService.
   * @constructor
   * @param http - Provides http service.
   * @param ngZone - Public property provides possibility for ngZone.runOutsideAngular.
   * @return {PfDataService}
   */
  constructor(protected http: Http, public ngZone: NgZone) {
    if (PfDataService.singleton) return PfDataService.singleton;
    PfDataService.singleton = this;
    this.getTmpCfg();
  }

  /**
   * Will check for change and call login with new arguments if needed.
   * @param params
   */
  setLang(params: {lcc?: string, lcd?: string}): void {
    let changed = false;
    Object.keys(params).forEach(key => {
      if (this._sessionData[key] !== params[key]) changed = true;
    });
    if (changed) {
      this.login(params);
    }
  };

  /**
   * Method do recive raw payload data without conversion into any kind of model.
   * Node: udfData will hold passed params contextModel as context.
   * @param params
   * @returns {Observable<UDFModel>}
   */
  getData(params: ContextModel<any>): Observable<UDFData> {
    return this._sendRequest(params, true);
  }

  /**
   * The login request is the first request that has to be called before any other request can be executed.
   * If another request is called before the login request is made automatically without any parameters and
   * will have as result an anonymous login with lcc and lcd defined as default in the database or if jet set,
   * from server side users session.
   * @param {ILoginParams | ContextModel} [params]
   * @return {Observable<UDFModel>|any|Observable<UDFModel>}
   */
  login(params?: ILoginParams | ContextModel<any>): Observable<UDFModel> {
    const observable = this._bindRequest(params, LoginParams);
    // Subscribe to make sure login is send even without subscription.
    observable.subscribe(blah => {});
    return observable;
    // params.smp = /* with sitemap data */ params.smp || smp || 7;
  }

  /**
   * Make sure we have _sessionData (login) loaded and
   * @param what - Name of property
   * @return {any} - Some property of _sessionData
   */
  getSessionData(what?: string): Observable<any> {
    let observable;

    const selectData = (function(key): any {
      // The res of login observable does not hold all sessionData as it was mapped in _extractData
      // and where complete responds was assigned to this_extractData.
      // We have to get it directly from _sessionData.
      if (!key) {
        // Return clone on complete session data.
        // Note: This only prevents changes in object on first level,
        // subobject can still be manipulated.
        return Object.assign({}, this._sessionData);
      } else if (this._sessionData[key] !== void 0) {
        // Return requested item of session data.
        let data = this._sessionData[key];
        if (data instanceof Array) {
          data = [].concat(data);
        } else if (data instanceof Object) {
          data = Object.assign({}, data);
        }
        return data;
      } else {
        // observer.error(`Error fetching session data. Key "${what}" not found in sessionData.`);
      }
    }).bind(this);

    observable = Observable.create(observer => {

      if (!this._sessionData) this.login();

      const sessionDataSubscription = Observable.create(sessDataObserver => {
        // The sessDataObserver will receive login data automaticaly when added to subscribers.
        this._addSubscriber(sessDataObserver, {sessiondata: what});
        // If sessiondata is allready there we have to pass data ourselves.
        if (this._sessionData) {
          sessDataObserver.next(this._sessionData);
        }
        return () => {
          this._removeSubscriber(sessDataObserver, {sessiondata: what});
        };
      }).subscribe( /* is sessDataObserver */
        loginData => {
          const data = selectData(what);
          observer.next( data );
        }
      );

      return () => {
        sessionDataSubscription.unsubscribe();
      };
    });

    return observable;
  }

  getSitemap(): Observable<UDFModel> {

    const max = 0;

    return Observable.create(observer => {
      const subscription = this.getSessionData('sitemap').subscribe(res => {
        res.forEach(item => {
          if (item.config) {
            item.items = [{items: [item.config]}];
          }
        });

        const udfData = {
          name: 'sitemap-data',
          desc: 'Sitemap',
          header: [{name: 'config', desc: 'Config'}],
          items: max ? res.slice(0, max) : res
        };
        if (max){
          console.warn(`Remember!! PfDataService@getSitemap: Developing with  res.slice(0, ${max})!`);
        }
        const udfModel = new UDFModel(udfData);
        observer.next(udfModel);

      });
      return () => {
        // alert('unsubscribe getSitemap')
        subscription.unsubscribe();
      };
    });
  }

  getCountries(): Observable<OptionList> {
    return Observable.create(observer => {
      const subscription = this.getSessionData('countries')
        .subscribe(res => {
          observer.next(
            /**
             * We reduce the countries data to an OptionList array
             * holding items of type IOptionListItem with properties: desc, value and type (lcc).
             */
            res.reduce((red, obj) => {
              const item: IOptionListItem = {desc: obj.country_desc, value: obj.country_cod, type: 'lcc'};
              if (this._sessionData.lcc === obj.country_cod) item.active = true;
              red.push(item);
              return red;
            }, new OptionList())
            /* End of result reduction */
          );
        });
      return () => {
        subscription.unsubscribe();
      };
    });
  }

  getHz(): Observable<OptionList> {
    return Observable.create(observer => {
      const subscription = this.getSessionData('countries')
        .subscribe(res => {

          /**
           * We reduce the countries data to an OptionList array
           * holding items of type IOptionListItem with properties: desc, value and type (frq).
           */
          const result: OptionList = new OptionList();
          const hzMap = {};
          const sess = this._sessionData;
          let refId: string;

          // Pic hz from session if possible.
          // First we get all possible/existing keys/values and set them in hzMap.
          for (let i = 0; i < sess.countries.length; i++ ) {
            const country_obj = sess.countries[i];
            if (country_obj.customvalue) {
              const cv_arr = country_obj.customvalue.filter(obj => {
                return !!obj.ref_id;
              }).forEach(obj => {
                hzMap[obj.ref_id] = obj.desc;
              });
            }
          }

          // Check which should be the active one.
          // If psf is set in session, we use that setting.
          if (sess.psf && /Frequency/g.test(sess.psf)) {
            refId = PfDataService.psToObj(sess.psf)['Frequency'].pop();
          } else {
            // Otherwise we pic hz from active country.
            for (let i = 0; i < sess.countries.length; i++ ) {
              const country_obj = sess.countries[i];
              if (country_obj.country_cod === sess.lcc) {
                if (country_obj.customvalue) {
                  const cv_arr = country_obj.customvalue.filter(obj => {
                    return obj.ref_id ? !!hzMap[obj.ref_id] : false;
                  });
                  refId = cv_arr.length ? cv_arr[0].ref_id : refId;
                }
                break;
              }
            }
          }

          for (const key in hzMap) {
            const obj: IOptionListItem = {value: key, desc: hzMap[key], type: 'frq'};
            if (key === refId) obj['active'] = true;
            result.push(obj);
          }

          observer.next(result);

        });
      return () => {
        subscription.unsubscribe();
      };
    });

  }

  getLanguages(): Observable<OptionList> {
    return Observable.create(observer => {
      const subscription = this.getSessionData('langdata')
        .subscribe(res => {
          observer.next(
            /**
             * We reduce the countries data to an OptionList array
             * holding items of type IOptionListItem with properties: desc, value and type (lcc).
             */
             Object.keys(res).reduce( (red, key) => {
               if (! red.some(obj => key === obj.lang_cod)) {
                 const obj: IOptionListItem = {desc: res[key], value: key, type: 'lcd'};
                 if (key === this._sessionData.lcd) obj.active = true;
                 red.push(obj);
               }
               return red;
             }, new OptionList()).sort((a, b) => {
               if (typeof a.desc === 'string' && typeof b.desc === 'string') {
                 return (a.desc.toUpperCase() < b.desc.toUpperCase()) ? -1
                 : (a.desc.toUpperCase() > b.desc.toUpperCase() ? 1 : 0);
               }
             })
            /* End of result reduction */
          );
        });
      return () => {
        subscription.unsubscribe();
      };
    });
  }


  getMask(params: IMaskParams | ContextModel<any> | Observable<UDFModel>): Observable<MaskModel> {
    return this._bindRequest(params, MaskParams, (model: UDFModel) => {
      // Nothims yet to do.
      return model;
    });
  }

  /**
   *
   * @param params
   * @param query
   * @return {Observable<UDFModel>|any|Observable<UDFModel>}
   */
  getList(params: IListParams | ContextModel<any> | Observable<UDFModel>, query?: string): Observable<ListModel> {

    return this._bindRequest(params, ListParams, (model: UDFModel) => {
      if (query)
       return model.query(query);
      return model;
    });

  }

  /**
   *
   * @param pathOrParams
   * @param query
   * @return {Observable<UDFModel>|any|Observable<UDFModel>}
   */
  getDetail(params: IDetailParams | ContextModel<any> | Observable<UDFModel> , query?: string): Observable<UDFModel> {

    return this._bindRequest(params, DetailParams, (model: UDFModel) => {
      if (query)
        return model.query(query);
      return model;
    });

  }


  /**
   * This Method allows us to pass as argument to getMask, getList, etc.
   * 1) A IListParams object. Uses the object as params for creation of contextModel.
   * 2) An ContextModel instance. Uses the contextModel as params for creation of contextModel.
   * 3) An Observable<UDFModel> instance. Subscribe to observable<UDFModel> and gets the udfModel.context
   * for creation of contextModel.
   *
   * UDFModel has a context in form of an ContextModel/ObservableModel, which holds basically the
   * query params (contextModel.params) for the server.
   * This observableModel instance can be bound/synced to an other context/observableModel.
   * For example when context of mask is synced wth context of list, the list model will automatically
   * update when change takes place in mask contect/model.
   * @param params
   * @param fn
   * @param transformFn
   * @return {any}
   * @private
   */
  private _bindRequest(params: any = {}, ContextClass: any, transformFn?: (res: any) => any ) {

    const request = (contextModel: ContextModel<any>): Observable<UDFModel> => {

      // Passing contextModel as argument to constructor of nay ParamsModel (ContextClass derived from ObservableModel)
      // will result in chaining/binding there properies together.

      const requestContext = new ContextClass(contextModel);
      // console.log('requestContext requestContext=', requestContext, ' contextModel=', contextModel)

      return Observable.create(observer => {
        const subsciption = this._sendRequest(requestContext).subscribe(

          (model: UDFModel) => {
            observer.next( transformFn ? transformFn(model) : model );

          }
        );
        return () => {
          subsciption.unsubscribe();
        };
      });

    }

    if (params instanceof ContextModel) {
      return request(params);
    }  else if (params instanceof Observable) {
      return Observable.create(observer => {
        const subsciption = (params as Observable<UDFModel>).subscribe(
          (model: UDFModel) => {
            request(model.context).subscribe(
              res => {
                observer.next(res);
              }
            );
          }
        );
        return () => {
          subsciption.unsubscribe();
        };
      }); /* End Observable.create */
    } else if (params instanceof Object) {
      params = new ContextModel(params);
      return request(params);
    }
  }


  private _sendRequest(context: ContextModel<any>, raw?: boolean): Observable<UDFModel | UDFData> {
    if (!(context instanceof ContextModel)) {
      console.warn('PfDataService@_sendRequest: context is not of type contextModel');
      return;
    }
    const params = context.params;
    let observable;

    // Todo: Make own model for sp and attr etc. String to obj and obj to string defined by class prooperies.
    for (const ps of ['psg', 'psh']){
      if (params[ps] && params[ps] instanceof Object)
        params[ps] = PfDataService.objToPs(params[ps]);

      if (!params[ps]) delete params[ps];
    }

    if (raw) params.raw = 1;


    /**
     * We have to be logged in before we make any further calls to the web service.
     * We check if we have logged in, what would means the _sessionData data is set.
     * If that's not the case and the current request is not a login request
     * we will login and fetch session date first.
     * Note: Session date holds the current language and country codes lcd and lcc etc. for
     * further requests.
     */

    if (!this._sessionData && params['fnc'] !== PfDataService.requestTypes.LOGIN ) {
      observable = Observable.create(observer => {
        const subscription = this.login()
          .subscribe (
            loginRes => {
              // Login went ok and _sessionData is set in map function _extractData.
              // Now we can make the requested call.
              this._sendRequest(params)
                .subscribe(
                  res => observer.next(res),
                  err => observer.next(err)
                  // ,() => { observer.complete(); }
                );
            },
            err => observer.next(err)
          );

        // Allow unsubscription
        return () => {
          subscription.unsubscribe();
        };

      }); /* End Observable create */

    } else {

      const resultRef = this._paramsToRef(params);

      if (this._results[resultRef] === void 0 /* no result cached */ ) {
        // We set lcc and lcd if not defined in params.
        if (this._sessionData /* logged in */) {
          // Not initial login request. Let's add sessions lcc and lcd to params if not set otherwise.
          if (!params['lcc']) params['lcc'] = this._sessionData['lcc'];
          if (!params['lcd']) params['lcd'] = this._sessionData['lcd'];
        }


        const request = this.http.get(PfDataService.baseUrl, {
          headers: this._buildHeaders(),
          search:  this._buildURLParams(params)
        })

        const subscription = request
          .map((responds) => {
            this._extractData(responds, context, raw);
          })
          .catch(this._handleError.bind(this))
          .subscribe(res => {
            subscription.unsubscribe();
            // console.log('Request Complete', params);
          });

        // Add subscription as result to allow canceling / unsubscription.
        this._results[resultRef] = /* loading started */ subscription;
      }

      observable = Observable.create(observer => {
        this._addSubscriber(observer, resultRef);
        // If result exists we pass it to observer.
        if (this._results[resultRef] && !(this._results[resultRef] instanceof Subscription)) {
          // We need to delay stream to simulate async behavior
          // otherwise it could lead to unexpected behavior.
          setTimeout(() => observer.next(this._results[resultRef]));
        }
        return () => {
          this._removeSubscriber(observer, resultRef);
        };
      });

    }

    return observable;
  }

  /**
   * I don't use it any more. Delete?
   * @param method
   * @param args
   * @param fnc
   * @return {any}
   * @private
   */
  private _wrapRequest(method: (...args: any[]) => Observable<UDFModel>, args: any[] | string, fnc: (res: any) => any ): Observable<UDFModel> {
    if (! (args instanceof Array)) args =  [args];
    const observable = Observable.create(observer => {
      const subscription = method.apply(this, args)
        .subscribe(
          res => observer.next(fnc(res))
        )
      return () => {
        subscription.unsubscribe();
      };
    });
    return observable;
  }

  private _buildHeaders(): Headers {
    const headers = new Headers();
    headers.append('Accept', 'application/json');
    // headers.append('Accept', '*/*');
    headers.append('Content-Type', 'application/json');
    return headers;
  }

  private _buildURLParams(mixIn?: Object): URLSearchParams {

    const args = Object.assign({}, this._baseArgs, (mixIn || {}));
    const parsm = new URLSearchParams();
    for (const prop in args) {
      if (args[prop] !== void 0) parsm.set(prop, args[prop]);
    }
    return parsm;
  }

  private _extractData(resp: Response, context: ContextModel<any>, raw?: boolean): Object {
    const resultRef = this._urlToRef(resp.url);
    const body: any = resp.json();
    if (body.error && body.error.length) {
      throw new Error( body.error.join('\n') );
    }
    let data: any = body.result || {};

    // UDFModel needs in root node the query as context,
    // so we have to shift it manualy into result namespace.
    data.context = context;

    // Same as context.params.fnc;
    const requestType = Number(body.query.fnc);

    switch (requestType) {

      case PfDataService.requestTypes.LOGIN:
        this._sessionData = data as ISessionData;
        break;

      case PfDataService.requestTypes.MASK:
        if (!raw)
          data = new MaskModel(data);
        break;

      case PfDataService.requestTypes.LIST:
        if (!raw)
         data = new ListModel(data);
        break;

      case PfDataService.requestTypes.DETAIL:
        // Todo: Change structure on server.
        data.equal.context = data.context;
        data.equal.name = data.name;
        data.equal.desc = data.desc;
        data.equal.nodetype = body.id_nodetype;
        data = !raw ? new UDFModel(data.equal) : data.equal;

        break;
    }


    if (context.params.fnc === PfDataService.requestTypes.LOGIN) {
      // We have to delete the login result (it's state 'false' when loading),
      // so next time when login is requested the login result does not come out of the _results cache
      // and http.get for login is triggered again.

      delete this._results[resultRef];

      Object.keys(this._subscribers).forEach(key => {
        // Subscribers for sessiondata actually subscribe to login data.
        if (/sessiondata/.test(key)) {
          // Need to assign to variable as the array can modified in iteration.
          const subscribers = [].concat(this._subscribers[key]);
          for (let i = 0; i < subscribers.length; i++) {
            subscribers[i].next(data);
          }
        }
      });

      Object.keys(this._subscribers).forEach(key => {
        // If not sessiondata and we are currently in login process,
        // all results are no longer valid and have to be removed and destroyed.
        let currentContext;
        if (! /sessiondata/.test(key)) {
          if (this._results[key] instanceof UDFModel) {
            currentContext = (this._results[key] as UDFModel).context;
            this._destroyModel(this._results[key]);
          }

          if (this._results[key] instanceof Subscription)
            (this._results[key] as Subscription).unsubscribe();

          delete this._results[key];

          // If it's not a login request (and not sessiondata)
          // we have to resend request with new login params (lcc, lcd)
          if (! /fnc=0/.test(key)) {
            this._sendRequest(currentContext || this._refToParams(key));
          }

          context = void 0;
        }
      });
    }

    if (this._subscribers[resultRef]) {
      const subscribers = this._subscribers[resultRef];
      if (requestType !== PfDataService.requestTypes.LOGIN) {
        // We save the result to ower  _results cache.
        this._destroyModel(this._results[resultRef]);
        this._results[resultRef] = data;
      } else {
        // All login subscriptions are internal observables, waiting for login this._subscribers to be set.
        // and when executed new observers of sub observables add "real" subscriptions.
        delete this._subscribers[resultRef];
      }

      for (let i = 0; i < subscribers.length; i++) {
        subscribers[i].next(data);
      }
    }

    return  data;
  }

  private _handleError(error: Response  | any) {
    let errMsg: string;
    if (error instanceof Response) {
      let body;
      try {
        /* Play safe: When body is not json encoded error.json() would throw an error too */
        body = error.json() || error['_body'];
      } catch (e) {
        body = {error: error['_body']};
      }
      const err = body.error || JSON.stringify(body);
      errMsg = `${error.status} - ${error.statusText || ''} ${err}`;
    } else {
      errMsg = error.stack ? error.stack : error.toString();
    }
    console.error('PfDataService ' + errMsg);
    return Observable.throw(errMsg);
  }

  private _refToParams(ref: string): Object {
    const res = {},
      obj = {},
      exp = /([^?=&]+)(=([^&]*))?/g,
      skip = ['lcc', 'lcd', 'login', 'pass'];

    ref.replace(new RegExp(exp), ( ($0, $1, $2, $3) => {if ($3) obj[$1] = $3; }).bind(obj) );
    const keys = Object.keys(obj).sort( (a, b) => {
        return (a > b ? 1 : (a < b ? -1 : 0));
      });

    keys.forEach(key => {
      // if (skip.indexOf(key) === -1 )
      if (! this._baseArgs[key] && skip.indexOf(key) === -1)
        res[key] = decodeURIComponent(obj[key]);
    });

    return res;
  }

  private _paramsToRef(params: object): string {
    const arr = [],
      skip = ['lcc', 'lcd', 'login', 'pass'],
      obj = this._refToParams( this._buildURLParams(params).toString() );

    for (const key in obj) {
      if (! this._baseArgs[key] && skip.indexOf(key) === -1)
        arr.push(key + '=' + obj[key]);
    }

    return arr.join('&');
  }

  private _urlToRef(url: string): string {
    const params = this._refToParams(url);
    return this._paramsToRef( params );
  }


  private _addSubscriber(subscriber: Subscriber<any>, refo: string | Object ) {
    const ref = (refo instanceof Object) ? PfDataService.objToQueryString(refo) : refo;
    if (!this._subscribers[ref]) this._subscribers[ref] = [];
    this._subscribers[ref].push(subscriber);
  }

  private _removeSubscriber(subscriber: Subscriber<any>, refo: string | Object ) {
    const ref = (refo instanceof Object) ? PfDataService.objToQueryString(refo) : refo;
    if (this._subscribers[ref]) {
      this._subscribers[ref].splice(this._subscribers[ref].indexOf(subscriber), 1);
      if (this._subscribers[ref].length === 0) {
        delete this._subscribers[ref];
        // Note: Removing result means that for a possible new subscription data will be fetched again.
        // Is this good?
        this._destroyModel(this._results[ref])
        delete this._results[ref];
      }
    } else {
      console.warn('DataService#_removeSubscriber: Can\'t finde ref "' + ref + '" in _subscribers.');
    }
  }

  public getTmpCfg(): Observable<any> {
    return this.http.get('assets/tpl-conf.css')
      .catch( (error) => this._handleError(error) );
  }

  private _destroyModel(obj: any) {
    // QuickFix! Todo: Find better solution to desroy current Model on unsubsccrube.
    if (obj instanceof UDFModel) {
      this.ngZone.runOutsideAngular(() => {
        setTimeout(() => {
          this.ngZone.run(() => {
            obj.destroy();
          });
        }, 5000);
      });
    }
  }
}

export class OptionList extends XArray<IOptionListItem> {
  public get selectedItems(): IOptionListItem[] {
    return this.filter(item => { return item.active; });
  }
  public get selectedItem(): IOptionListItem {
    for (let i = 0; i < this.length; i++) {
      if (this[i].active) return this[i];
    }
  }
}

