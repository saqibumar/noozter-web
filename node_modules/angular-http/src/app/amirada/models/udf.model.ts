/*
import {forEach} from '@angular/router/src/utils/collection';
import { Component, Inject, Optional } from '@angular/core';
*/
import { PFCONST } from '../consts';

import 'rxjs/add/observable/throw';
import { PfDataService } from '../data.service';
import { ObservableModel } from './obs.model';
import { XArray } from './xarray';

import {
  EventEmitter
} from '@angular/core';


export class UDFData {
  name?: string;
  desc?: string;
  index?: number;
  nodeType?: number;
  dataType?: number;
  cod?: string;
  header?: UDFData[];
  items?: UDFData[];
  attribs?: string;
  attr?: object;
  value?: any;
  context?: any;
  count?: number;
}



export class UDFModel implements Iterable<UDFModel> {

  // public ChildClass = UDFModel;

  // static instLookup: Map<Element, UDFModel> = new Map<Element, UDFModel>();
  static instLookup: Map<string, UDFModel> = new Map<string, UDFModel>();
  static toStringAttrs  = ['level', 'name', 'id'];
  static toTextAttrs = ['id', 'name', 'index', 'desc', 'path', 'level',  'nodeType', 'dataType', 'attr', 'value'];
  static toJsonAttrs = UDFModel.toTextAttrs; // .concat(['children']);
  static cid = 0;
  static ginfo: any;

  protected _data: UDFData;
  protected _cache: UDFCache = {tmp: {}};
  private _cid: number;
  private _link: UDFLink;
  private _children: UDFModel[];
  private _el: Element;
  private _change: EventEmitter<UDFModel> = new EventEmitter();

  /* options come in handy when derivating UDFModel. */
  public options: any;


  constructor(data?: UDFData, link?: UDFLink, options?: any) {

    this._link = link || new UDFLink(null, this);

    if (! UDFModel.ginfo ) UDFModel.ginfo = {};
    this.options = options;

    this._cid = UDFModel.cid ++

    if (data) {
      this.parseData(data);
    }
  }

  /**
   * Implementing Iterable interface.
   * By implementing the iterable interface the model can directly iterated over.
   * Note: Allows the used of IterableDiffers.
   * Todo: model.forEach!!
   */

  [Symbol.iterator]() {
    let pointer = 0;
    const models = this.children;

    return {
      next(): IteratorResult<UDFModel> {
        if (pointer < models.length) {
          return {done: false, value: models[pointer++]};
        } else {
          return {done: true, value: null};
        }
      }
    };
  }

  parseData(data: UDFData): UDFModel {

    // Todo: Need some clean up if update. Do I need update param?
    this._data = this._mapData(data);
    this._cache = {tmp: {}};
    // Todo: remove children;
    delete this._children;

    UDFModel.instLookup.set(this.uid, this);

    this._createEl();
    this._createChildren();

    // Todo: check if parent._data.items(parent.indexOf(this) === this._data) and set it different needed.

    return this;
  }

  public updateData(data: UDFData) {
    this._cache = {tmp: {}};
    this._data = this._mapData(data);

    this.updateChildren(this._data.items);
  }

  public destroy() {
    if (!this._cache) {
      console.warn('Todo: UDFModel#destroy check why !this._cache!');
      return;
    }

    // First of all destroy children
    while (this.children.length)
      this.children[0].destroy();

    if (this.level === 'compound')
      this._cache.header.destroy()


    // Remove el from dom reflection. Column has no element ( yet ).
    if (this.el) this.el.parentNode.removeChild(this.el);


    // Remove from parent UDFModel.
    // (removeChild does not destroy child!);
    if (this.parent) this.parent.removeChild(this);



    // Destoing link to this model.
    // Link will unregister from UDFLink.linkList.
    this._link.destroy();

    // Unregister from UDFModel.instLookup.
    UDFModel.instLookup.delete(this.uid);
    // console.log('instLookup remove', this.uid)



    // Stop context sync by destroying this context ObservableModel.
    // if (this === this.root) this.context.destroy();

    this._cache = {};
    delete this._el;
    delete this._children;



    this._change.emit(this);
    // Release subscriptions to EventEmitter.
    if (this.parent)
      this._change.complete();

  }

  get el(): Element {
    // console.log('get el')
    if (this._el) return this._el;
    return this._el = this._createEl();
  }

  private _createEl(): Element {
    if (this._el) return this._el;
    if (this.level === 'column') return;
    this._el = document.createElement(this.level);
    this._updateEl();
    return this._el;
  }

  private _updateEl() {
    if (!this._el) return;
    const el = this._el;
    if (this.parent) {
      // Just a regular node
      this.parent.el.appendChild(el);
    } else {
      // A request node.
      // We check if wrapper node is existent, ...
      let wrapper = document.getElementsByTagName('udf')[0];
      // ... if not so we create it.
      if (!wrapper) {
        wrapper = document.createElement('udf');
        wrapper.appendChild(document.createElement('style'));
        document.body.appendChild(wrapper);
        PfDataService.singleton.getTmpCfg().subscribe(
          res => { wrapper.querySelector('style').innerHTML =  res._body; }
        );
      }
      // We should have a context if there is no parent.
      if (this.context) {
        // Add string for request/context type.
        // Map the context id/function to something readable by using the key of requestTypes.
        for (const key in PfDataService.requestTypes) {
          if (PfDataService.requestTypes[key] === Number(this.context.params.fnc)) {
            el.setAttribute('request', key);
            break;
          }
        }
      }
      wrapper.appendChild(el);
    }

    const attrs: object = this.attr;
    el.setAttribute('id', this.uid);
    el.setAttribute('name', this.name);
    el.setAttribute('desc', this.desc);
    el.setAttribute('level', this.level);

    /**
     * The CLS attribute is mend to be used to groups data.
     * A model can form part of various groups depeending on link.
     * i.e. table, tile-left, tab1-x ...
     */
    if (this.attr['CLS']) el.className = this.attr['CLS'];

    /**
     * The attr object is converted to a list of whitespace-separated key-values pares
     * separated by :
     * i.e. "SGO:1 SMU:2 ..."
     * and can be queried [attr~=SGO:1]
     */
    el.setAttribute('attr', PfDataService.objToQueryString(this.attr, ' ', '-'));
  }

  get assignedComponent(): string {
    if (this._cache.assignedComponent) return this._cache.assignedComponent;

    let comName = window.getComputedStyle(this.el, null).getPropertyValue('content');
    if (!comName) comName =  this.level;
    return comName.replace(/"/g, '');
  }

  set assignedComponent(compType: string) {
    this._cache.assignedComponent = compType;
  }

  query(selector: string): UDFModel[] {

    let matches: NodeList;
    try { // Prevent DOMExecution error.
      matches = this.el.querySelectorAll(selector);
      const result = Array.prototype.map.call(matches, node => {
        return UDFModel.instLookup.get(node.id);
      });

      return result;
    } catch (err) {
      console.warn(err.message);
      return [];
    }
  }

  filter(fnc: (item: any) => boolean, deep?: boolean ): UDFCollection {

    // Apply filter on arrays filter method
    const filtered = this.children.filter(fnc);
    const result = new UDFCollection(filtered);

    if (deep) {
      // Apply filter on children's filter method.
      for (let i = 0; i < this.children.length; i++) {
        const subResult = this.children[i].filter(fnc, deep);
        // Can't use concat because subResult is not exceped as
        // type of array and would be pushed into as single element.
        for (let x = 0; x < subResult.length; x++) {
          result.push(subResult[x]);
        }
      }
    }

    return result;

    /*
    const fnType = 'filter';
    filtered[fnType] = UDFModel.prototype[fnType] = function(){
      let resArr = [];
      for (let i = 0; i < this.length; i++) {
        const subresArr = this[i][fnType].apply(this[i], arguments);
        resArr = resArr.concat(subresArr);
      }
      return resArr;
    };
    */

  }

  /**
   * The UDFMeta[] header is defined in the compound object as array of objects, of which
   * each object is the UDFMeta object for a cell of a record. Records and values do not have
   * there own header object but refer to the UDFMeta of the parent object.
   * Compound UDFMeta object: Is the compount data itself.
   * Record UDFMeta object: UDFMeta object from compound.
   * Cell UDFMeta object: Object included in compound header, fetched by cell index.
   * Value UDFMeta object: UDFMeta object from Cell.
   */
  get meta(): UDFModel {

    // if (this._cache.meta) return this._cache.meta as UDFModel;

    let meta, errMsg;
    const compound = this.getAncestor('compound');

    if (this.level === 'compound' && this.parent) {
      // Compound in a cell get column meta.
      meta = this.parent.meta;

    } else if (this.level === 'compound') {
      // The data itself is meta just with additional items;
      meta = this._data; // Or better use 'this' ?

    } else if (this.level === 'record') {

      // Record has same header than compound, so a single
      // record can create a table/compound with just one row/record.
      meta = compound.meta;

    } else if (this.level === 'cell') {

      // A cell a header object found at the cells index in the compound header.
      // To avoid errors we validate data:
      // cellCount must be same as length of compound header array.
      const headersCount = compound.header ? compound.header.length : 0;
      const cellCount = this.parent.length;

      if (headersCount !== cellCount) {
        errMsg = `@UDFMode#meta Wrong amount of header items in header of compound "${compound.name}"!:
          Number of cells (${cellCount}) != number of header items (${headersCount}).`;
        // This error can lead to recursive loop. Throw error and die.
        throw new Error(errMsg);
        /*
        console.warn(errMsg, compound);
        return ({} as UDFModel);
        */
      }

      // GreQ: Reduce model to Real object otherwise not assign for getters.
      meta = Object.assign({}, compound.header[this.index].options.columnData);
      delete meta.items;

    }  else if (this.level === 'value') {

      // The value gets the cell header. In case the cell header contains a header
      // Use that header instead as the value, in this case, is a sub compound.
      meta  = this.parent.meta;

    } else if (this.level === 'column') {
      // Column is meta itself.
      meta = this._data; // Or better use 'this' ?
    } else {
      // Why should this happen?
      console.warn(`ItemModel#meta Error: Wrong level "${this.level}" compound "${compound.name}"`, compound);
    }


    return this._cache.meta = meta;
  }

  get context(): any {
      if (this !== this.root && !this.parent){
        // Something when wrong.
        debugger;
        return;
      }
      return (this !== this.root) ? this.root.context : this._data.context;
  }

  get attr(): any {
    if (this._cache.attr ) return this._cache.attr;
    let attr: object;

    if (this.level === 'compound' && this.meta.attr) {
      // Compound in a cell with the attr located in header.
      attr = Object.assign({}, this.meta.attr);

    } if (this.level === 'column') {
      // Compound in a cell with the attr located in header.
      attr = Object.assign({}, this._data.attr);

    } else if (this.level === 'record' || this.level === 'value') {
      // Record inherits from compound, value from cell (column meta object).
      attr = Object.assign({}, this.parent.attr);

    } else if (this.level === 'cell') {
      // cell shares same attr from column meta object from compound header array.
      attr = Object.assign({}, this.meta.attr);

    }
    // In addition to the attr passed in header array an item can have it's own attribs.
    // Note: Own attributes override inherited attributes.
    if (this._data.attribs) {
      attr = Object.assign({}, this._parseAttribs(this._data.attribs));
    }

    return  this._cache.attr = (attr || {});
  }

  protected _parseAttribs(attribs_str?: string): object {
    return PfDataService.queryStringToObj(attribs_str, ',', '=', null, false, true);
  }

  get length(): number {
    /* We geht the length of _data.items as constructed child
    might not be added to children yet.
    */
    return this._data.items.length;
  }

  get header(): UDFHeader {

    if (this._cache.header) { return this._cache.header; }

    if (this.level === 'compound') {

      if (this._data.header) {
        let arr = [];
        if (this._data.header instanceof Array) {
          arr = [].concat([], this._data.header);
          /*  Convert associated to indexed array if necessary */
        } else if (this._data.header instanceof Object) {
          let i = 0;
          do {
            arr.push(this._data.header[i]); i++;
          } while (this._data.header[i]);
        }

        const udfHeader = new UDFHeader(this._data.header, new UDFLink(this));
        return this._cache.header = udfHeader;

      }
    }

    return this._cache.header;
  }


  get parent(): UDFModel {
    return this._link.source;
  }

  getAncestor(level?: string): UDFModel {
    let ancestor: UDFModel = this;
    // return this parent if no level passed.
    if (!level) return this.parent;

    while (ancestor) {
      // Found item matching level.
      if (ancestor.level === level) {
        return ancestor;
      }
      // Not found. Let step up one level.
      ancestor = ancestor.parent;
    }
    return ancestor;
  }

  get root(): UDFModel {
    if (this._cache.root !== void 0) return this._cache.root;
    return this._cache.root = (this.parent ?  this.parent.root : this);
  }

  get depth(): number {
    if (this._cache.depth !== void 0) return this._cache.depth;

    let depth;

    if (this._data.header /* Ist always a coumpond */) {
      depth = 0;
    } else if (this.parent) {
      depth = this.parent.depth + 1;
    } else {
      // Empty coumpound
      depth = 0;
    }
    // If it's the last / the value depth (3 == value level)
    // and we have items then this must be a sub compound.
    if (depth === 3 && this._data.items) { /*this._data.header*/
      depth = 0;
    }

    return this._cache.depth = depth;
  }

  get level(): string {
    if (this._cache.level) return this._cache.level;
    /* Note: Child class UDFColumn must implement own get level method */
    return this._cache.level = [
      'compound', /* 0 */
      'record', 	/* 1 */
      'cell',			/* 2 */
      'value'			/* 3 */
    ][this.depth];
  }

  get hidden(): boolean {
    return ((PFCONST.sgo_Hide & this.attr.SGO) === PFCONST.sgo_Hide);
  }

  get children(): UDFModel[] {
    if (!this._children) this._createChildren()
    return this._children;
  };

  private _createChildren(): Array<UDFModel> {
    if (!this._children) {
      this._children = [];
      this._children['parent'] = this;
      if (this._data.items && this._data.items.length) {
        this._data.items.forEach ((data) => {
          this.addChild(data);
        });
      }
    }
    return this._children;
  }


  protected addChild(data: any) {
    let index, child;
    if (!this._children) this._createChildren();
    if (this._data.items.indexOf(data) === -1)
      this._data.items.push(data);

    index = this._data.items.indexOf(data);

    /* Use constructor to create child of possible class derived from UDFModel */
    child = new (this.constructor as any)(data, new UDFLink(this));
    this._children[index] = child;
    // this.onchange.emit(this);
    this._emitChange();

  }

  protected updateChildren(items: Array<UDFData>) {
    if (!items) return; /* value level */

    if (items.length !== this.children.length) {
      console.warn('UDFMolde#updateChildren: Can\'t update. Wrong amount of items!');
      return;
    }

    for (let i = 0; i < items.length; i++) {
     this.updateChild(this.children[i], items[i]);
    }
  }

  protected updateChild(child: UDFModel | number, data: any) {
    let index;

    if (typeof child === 'number') {
      index = child as number;
    } else {
      index = this.indexOf(child);
    }

    child = this._children[index];

    if (child) {
      this._data.items[index] = data;
      child.updateData(data);
    } else {
      console.warn('UDFMolde#updateChild: Can\'t update child. Child not found! Child:', child);
    }

  };

  protected removeChild(child) {

    if (!UDFModel.ginfo ) UDFModel.ginfo = {};
    if (!UDFModel.ginfo.remCount ) UDFModel.ginfo.remCount = 0;

    UDFModel.ginfo.remCount += 1;

    const index = this.children.indexOf(child);
    // console.log('rem', UDFModel.ginfo.remCount, index, child.uid);
    if (index > -1) {
      this._data.items.splice(index, 1);
      this.children.splice(index, 1);
    }

  }

  private _emitChange() {
    this.onchange.emit(this);
    // this._callOnce('emitChange', () => { this.onchange.emit(this); });
  }

  protected _callOnce(ref: string, callback: any, args: Array<any> = []) {
    // Only emit event once when addChild is called in iteration.
    const toid = ref + '_TimeoutId';
    if (!this._cache.tmp[toid]) {
      // We have to run function with timeout without change detection,
      // otherwise it's a zone overkill and slows things down massively.
      PfDataService.singleton.ngZone.runOutsideAngular(() => {
          this._cache.tmp[toid] = setTimeout((() => {
            // console.log('_callOnce', this.uid, 'run', toid);
            delete this._cache.tmp[toid];
            // Reenter zone
            PfDataService.singleton.ngZone.run(() => {
              callback.apply(this, args);
            });
          }).bind(this));
      });
    }
  }

  get onchange(): EventEmitter<UDFModel> {
    return this._change;
  }

  get size(): number {
    return this._data.items ? this._data.items.length : 0;
  }

  // Count is not the amount of current childs but the total possible amount */
  get count(): number {
    if (this._data.count) {
      return Number(this._data.count);
    } else {
      return void 0;
    }
  }

  get index(): number {
    if (this._cache.index) { return this._cache.index; }
    return this._cache.index = this.parent ? this.parent.indexOf(this._data) : 0;
  }

  indexOf(obj: UDFModel | UDFData ): number {
    /* Note: We have to get the index from parent data.items not from children
     as the child needs index on creation before it's added to children in order to
     get the meta object from compound header */
    if (obj instanceof UDFModel) {
      return this._children.indexOf(obj);
    } else {
      if (this._data.items) {
        return this._data.items.indexOf(obj);
      } else {
        return -1;
      }
    }
  }

  get name(): string {
    return this._getProp('name');
  }

  get uid(): string {
    if (this._cache.id) return this._cache.id;
    let abrev = '';
    if (!this.parent) /* root  */ abrev += this._cid;
    abrev += '-';
    abrev +=  this.level.slice(0, 3).toUpperCase();
    const id =  this.parent ? this.parent.uid + abrev + this.index : abrev + this.index.toString();
    return this._cache.id = id;
  }

  get desc(): string {
    return this._getProp('desc');
  }

  get nodeType(): number {
    const nt = this._getProp('nodeType');
    return nt ? Number(nt) : 0;
  }

  get dataType(): number {
    const dt = this._getProp('dataType');
    return dt ? Number(dt) : 0;
  }

  get path(): string {
    return this._getProp('path');
  }

  private _getProp(type: string): string {
    /* Check if we have our own and if not then get it from meta. */
    try {
    return this.level !== 'value'
      ? (this._data[type] || this.meta[type])
      : (this._data[type] || (this.parent ? this.parent[type] : void 0));
    } catch (e) {
      const foo = 1;
    }
  }

  get value(): any {
    return this._data.value;
  }

  set value(val: any) {
    this._data.value = val;
  }

  protected _getByLevel(whichLevel: string, deep?: boolean): UDFCollection {
    const result = this.filter((model: UDFModel) => {
      return model.level === whichLevel;
    }, deep);

    return result;
  }

  getCompounds(deep?: boolean): UDFCollection {
    return this._getByLevel('compound', deep);
  }

  getRecords(deep?: boolean): UDFCollection {
    return this._getByLevel('record', deep);
  }

  getCells(deep?: boolean): UDFCollection {
    return this._getByLevel('cell', deep);
  }

  getValues(deep?: boolean): UDFCollection {
    return this._getByLevel('value', deep);
  }

  get getAllMethods() {
    let obj = this;
    let props = [];
    do {
      props = props.concat(Object.getOwnPropertyNames(obj));
    } while (obj = Object.getPrototypeOf(obj));

    return props.sort().filter(function(e, i, arr) {
      if ( e !== arr[ i + 1 ] && typeof obj[e] === 'function') return true;
    });
  }

  private _mapData(obj: any): object {
    // Need this for level check!!
    this._data = obj;

    // In case it's not value level and there are no items we add items
    // array in order to prevent undefined property/length error.
    if (obj.value === void 0 && !(obj.items instanceof Array) )
      obj.items = [];


    if (this.level === 'compound') {
      /* This is for a sub compound in a cell instead of value / value is a compound */
      if (this.parent && !obj.header) {
        /* Inherit meta from cell(column) */
        Object.assign(obj, this.parent.meta);
      }
    }

    if (obj.nodetype) {
      obj.nodeType = obj.nodetype;
      delete obj.nodetype;
    }
    if (obj.datatype) {
      obj.dataType = obj.datatype;
      delete obj.datatype;
    }
    return obj;
  }

  /**
   * Create a string with basic props
   * @return {string}
   */
  toString(): string {

    const arr = [];
    for (const key of UDFModel.toStringAttrs)
      if (this[key]) arr.push(key + ':' + this[key]);

    if (arr.length) {
      return `[${this.constructor.name}['${arr.join('][')}]]`;
    } else {
      return `[${this.constructor.name}]`;
    }
  }

  /**
   * Creates a string a key value pares delimited by newline + return;
   * When developing comes in handy in a <pre> tag.
   * @return {string}
   */
  toText(): string {
    const arr = [];
    UDFModel.toTextAttrs.forEach(prop => {
      let value = this[prop];
      if (value !== void 0) {
        switch (typeof this[prop]) {
          case 'string':
          case 'number':
          case 'boolean':
            value = value.toString();
            break;
          default:
            try {
              value = JSON.stringify(value);
            } catch (e) {
              value = value.toString ? value.toString() : '[' + value.constructor.name + ']';
            }
        }
        arr.push(prop + ': ' + value);
      }
    });

    return arr.join('\n\r');

  }

  toObject(): object {
    const obj = <any>{};
    for (const key of UDFModel.toJsonAttrs) {
      if (!this[key]) continue;
      obj[key] = this[key];
    }
    if (this.size) {
      obj.items = [];
      for (let i = 0; i < this._children.length; i++) {
        obj.items.push(this._children[i].toObject());
      }
    }
    return obj;
  }

  /**
   * Present an object that can be encoded by JSON.stringify.
   * @return {{}}
   */
  toJson(deep?: boolean): object {
    const result = {};

    UDFModel.toJsonAttrs.forEach(prop => {
      let value = this[prop];
      if (value !== void 0) {
        switch (typeof this[prop]) {
          case 'string':
          case 'number':
          case 'boolean':
            value = value.toString();
            break;
          default:
            try {
              const test = JSON.stringify(value);
              /* If it's ok to convert we can leave it as is. */
            } catch (e) {
              /* We convert to what ever possible. */
              value = value.toString ? value.toString() : '[' + value.constructor.name + ']';
            }
        }
        result[prop] = value;
      }
    });

    if (deep) {
      if (this.children.length) {
        result['children'] = [];
        this.children.forEach(child => {
          result['children'].push(child.toJson(deep));
        });
      }
    }

    return result;
  }

}

export class UDFMeta extends UDFModel {
  // private _header: UDFHeader;
  constructor(data: UDFData, link: UDFLink, header: UDFHeader) {
    if (data.items && data.items.length) /* Should never happen! */ debugger;
    super(data, link, {header: header, columnData: data});
    this._data.attr = this._data.attribs ? this._parseAttribs(this._data.attribs) : {};
  }

  get level(): string {
    return 'column';
  }

  get size(): number {
    // Same amount of records then compound.
    return this.parent.size;
  }

  get index(): number {
    // After header instance was initialized, applied as property and UDFMeta added to it.
    return (this.options.header as UDFHeader).data.indexOf(this.options.columnData);
    /*
    Todo: This is not working jet. Need this in case column order changes but at the moment this.parent => recursion.
    if (this.parent.header && this.parent.header.indexOf(this)) {
      return this.parent.header.indexOf(this);
    } else { // Case when new UDFHeader(UDFModel[])
      // Remember workaround: The index getter is called when super is called in constructor.
      // I pass the header instance in options to super so I have access here.
      return (this.options.header as UDFHeader).data.indexOf(this.options.columnData);
    }
    */
  }
}

export class UDFHeader extends XArray<UDFMeta> { /*implements IOptionList */

  /* Remember: Attribute data must made public for UDFMeta
  to define index before added to UDFHeader array. */
  public data: UDFData[];


  constructor(arr: UDFData[] = [], private link: UDFLink) {
    super();
    this.data = arr;
    try {
      for (let i = 0; i < arr.length; i++) {
        this.addColumn(arr[i]);
      }
    } catch (e) {
      console.warn('UDFHeader#constructor: Could not add column. ' + e.message);
    }
  }

  // @enumerable(false)
  public get selectedItems(): UDFMeta[] {
    return this.filter(item => { return item.active; });
  }

  public get selectedItem(): UDFMeta {
    for (let i = 0; i < this.length; i++) {
      if (this[i].active) return this[i];
    }
  }

  public addColumn(data: UDFData, index?: number): UDFModel {
    // Column has same link then record (source is compound)
    const column = new UDFMeta(data, this.link, this);
    this.push(column);
    return column;
  }

  public destroy() {
    while (this.length) {
      this.shift().destroy();
    }
  }

}


export class UDFCollection extends XArray<UDFModel> {
  constructor(arr?: UDFModel[] | UDFCollection) {

    // Somehow strange: When I move arr.length into for clause
    // I get the message "Property 'length' does not exist on 'never'",
    // but when I declare before constructor it's ok.

    const len = arr && (arr instanceof Array) ? arr.length : 0;
    super();

    if (arr instanceof UDFCollection) {
      return arr;
    } else if (arr && arr instanceof Array) {
      for (let i = 0; i < len; i++) {
        // if (arr[i] instanceof UDFModel)
          this.push(arr[i]);
      }
    }
    /*
    toString(): string {
      let arr = []
      for (var i = 0; i < this.length; i++){
        arr.push(this[i].toString());
      }
      string 'UDFCollection: [ ' + arr.join(',') + ' ]';
    }
    */
  }

  /**
   *  I have to write this one as method of base class add child class to array
   *  in stead of treating it like an array symbol.
   *  Note: Now its possible to concat from this class but still the other way around will not.
   *  i.e. xarray.concat(array) ok, array.concat(xarray) not ok.
   */
  /*
  addItems(...items: any[][]): UDFCollection {
    const args = Array.prototype.slice.call(arguments);
    const res = new UDFCollection();
    args.unshift(this);
    for (let i = 0; i < args.length; i++) {
      const arr = args[i];
      if (arr instanceof Array) {
        for (let x = 0; x < args[i].length; x++) {
          res.push(args[i][x]);
        }
      } else {
        res.push(arr);
      }
    }
    return res;
  }
  */
}
/*
UDFCollection.prototype['addItems'] = function (...items: any[][]): any[] {
  const args = Array.prototype.slice.call(arguments);
  const res = []
  args.unshift(this);
  for (let i = 0; i < args.length; i++) {
    const arr = args[i];
    if (arr instanceof Array) {
      for (let x = 0; x < args[i].length; x++) {
        res.push(args[i][x]);
      }
    } else {
      res.push(arr);
    }
  }
  return res;
}
*/

const mixIns = ['query', 'filter', 'getCompound', 'getRecord', 'getCell', 'getValue', 'toJson'];

for (let i = 0; i < mixIns.length; i++) {
  const fnName = mixIns[i];
  const fnFnc = UDFModel.prototype[fnName];
  UDFCollection.prototype[fnName] = function(){
    const context = new UDFCollection();
    for (let x = 0; x < this.length; x++) {
      const item = this[x];
      if (item instanceof UDFModel) {
        const res = fnFnc.apply(item, arguments);
        if (res instanceof Array) {
          while (res.length) context.push(res.shift());
        } else {
          context.push(res);
        }
      }
    }
    return context;
  };
}



export class UDFLink {

  static NORMAL = 0;
  static COLUMN = 1;
  static ALIAS = 2;

  static linkList: UDFLink[] = [];

  constructor(
    public source: UDFModel,
    public target?: UDFModel,
    public type: number = UDFLink.NORMAL
  ) {
    UDFLink.linkList.push(this);
  }

  destroy() {
    UDFLink.linkList.splice(UDFLink.linkList.indexOf(this), 1);
  }

}

/* Interfaces */

export interface UDFCache {
  id?: string;
  index?: number;
  name?: string;
  desc?: string;
  depth?: number;
  level?: string;
  attr?: object;
  header?: UDFHeader;
  root?: UDFModel;
  meta?: UDFMeta;
  el?: Element;
  assignedComponent?: string;
  loading?: boolean;
  tmp?: any;
}

export interface IOptionList {
  selectedItems: any[];
  selectedItem: any;
}
/*
interface Iterator<T> {
  next(value?: any): IteratorResult<T>;
  return?(value?: any): IteratorResult<T>;
  throw?(e?: any): IteratorResult<T>;
}
*/
export interface IteratorResult<T> {
  done: boolean;
  value: UDFModel;
}

